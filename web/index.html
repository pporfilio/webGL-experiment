<html>

<head>
    <title>Test</title>

    <script type="text/javascript" src="vendor/toji-gl-matrix-a8540ce/dist/gl-matrix-min.js"></script>
    <script type="text/javascript" src="vendor/webgl-utils/webgl-utils.js"></script>

    <script id="shader-fs" type="x-shader/x-fragment">
        precision mediump float;

        varying vec4 vColor;

        void main(void) {
            gl_FragColor = vColor;
        }
    </script>

    <script id="shader-vs" type="x-shader/x-vertex">
        attribute vec3 aVertexPosition;
        attribute vec4 aVertexColor;

        uniform mat4 uModelViewMatrix;
        uniform mat4 uProjectionMatrix;

        varying vec4 vColor;
        
        void main(void) {
            gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 1.0);
            vColor = aVertexColor;
        }
    </script>

    <script>
        function clamp(number, min, max) {
            return Math.max(min, Math.min(number, max));
        }

        function Camera() {
            this.pitch = 0; // radians
            this.yaw = 0; // radians
            this.position = [0, 0, 0]
        }

        Camera.prototype.addPitch = function(deltaPitch) {
            this.setPitch(this.getPitch() + deltaPitch);
        }

        Camera.prototype.setPitch = function(newPitch) {
            this.pitch = clamp(newPitch, -Math.PI / 2 + .1, Math.PI / 2 - .1);
        }

        Camera.prototype.getPitch = function() {
            return this.pitch
        }

        Camera.prototype.addYaw = function(deltaYaw) {
            this.setYaw(this.getYaw() + deltaYaw);
        }

        Camera.prototype.setYaw = function(newYaw) {
            this.yaw = newYaw;
        }

        Camera.prototype.getYaw = function() {
            return this.yaw;
        }

        Camera.prototype.addPosition = function(deltaPosition) {
            this.position[0] += deltaPosition[0];
            this.position[1] += deltaPosition[1];
            this.position[2] += deltaPosition[2];
        }

        Camera.prototype.setPosition = function(newPosition) {
            this.position = newPosition;
        }

        Camera.prototype.getPosition = function() {
            return this.position;
        }

        Camera.prototype.getCameraRotationMatrix = function() {
            var matrix = mat4.create();
            mat4.rotate(matrix, matrix, this.getPitch(), [1, 0, 0]);
            mat4.rotate(matrix, matrix, this.getYaw(), [0, 1, 0]);            
            return matrix;
        }

        Camera.prototype.getWorldToCameraMatrix = function() {
            var matrix = mat4.create();
            mat4.rotate(matrix, matrix, -this.getPitch(), [1, 0, 0]);
            mat4.rotate(matrix, matrix, -this.getYaw(), [0, 1, 0]);
            mat4.translate(matrix, matrix, vec3.negate(vec3.create(), this.getPosition()));
            return matrix;
        }

        Camera.prototype.getLookVector = function() {
            var vector = vec3.fromValues(0, 0, -1);
            vec3.transformMat4(vector, vector, this.getCameraRotationMatrix());
            return vector;
        }

        Camera.prototype.moveAlongLook = function(distance) {
            var lookVector = this.getLookVector();
            var moveVector = vec3.fromValues(lookVector[0], 0, lookVector[2]);
            vec3.normalize(moveVector, moveVector);
            this.addPosition([moveVector[0] * distance, 0, moveVector[2] * distance]);
        }

        Camera.prototype.movePerpendicularToLook = function(distance) {
            var orthogonal = vec3.cross(vec3.create(), this.getLookVector(), [0, 1, 0]);
            var moveOrthogonal = vec3.fromValues(orthogonal[0], 0, orthogonal[2]);
            vec3.normalize(moveOrthogonal, moveOrthogonal);
            this.addPosition([moveOrthogonal[0] * distance, 0, moveOrthogonal[2] * distance])
        }

        function initWebGL(canvas) {
            return canvas.getContext("webGL") || canvas.getContext("experimental-webgl");
        }

        function loadShader(gl, text, type) {
            var shader = gl.createShader(type);
            gl.shaderSource(shader, text);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                alert(gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }

        function createShaderProgram(gl, vertexShaderText, fragmentShaderText) {
            var vertexShader = loadShader(gl, vertexShaderText, gl.VERTEX_SHADER);
            var fragmentShader = loadShader(gl, fragmentShaderText, gl.FRAGMENT_SHADER);
            var shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);
            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                alert("Could not link shaders");
                return null;
            }
            var shaderProgramWrapper = { program: shaderProgram };
            return shaderProgramWrapper;
        }        

        function createFloatBuffer(gl, data, itemSize, drawType) {
            var floatBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, floatBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), drawType);
            var vertexBufferWrapper = { buffer: floatBuffer };
            vertexBufferWrapper.itemSize = itemSize;
            vertexBufferWrapper.numItems = data.length / itemSize;
            return vertexBufferWrapper;
        }

        function createU16ElementBuffer(gl, data, drawType) {
            var u16Buffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, u16Buffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(data), drawType);
            var u16BufferWrapper = { buffer: u16Buffer };
            u16BufferWrapper.itemSize = 1; // indices are always single elements
            u16BufferWrapper.numItems = data.length;
            return u16BufferWrapper;
        }

        function updateCubeColors(env) {
            env.gl.bindBuffer(env.gl.ARRAY_BUFFER, env.cubeColorBufferWrapper.buffer);
            var cubeColors = getCubeColors();
            var data = new Float32Array(cubeColors);
            env.gl.bufferSubData(env.gl.ARRAY_BUFFER, 0, data);
        }

        function getTriangleVertices() {
            return [
                 0.0,  1.0,  0.0,
                -1.0, -1.0,  0.0,
                 1.0, -1.0,  0.0
            ];
        }

        function getTriangleColors() {
            return [
                1.0, 0.0, 0.0, 1.0,
                0.0, 1.0, 0.0, 1.0,
                0.0, 0.0, 1.0, 1.0
            ];
        }

        function getSquareVertices() {
            return [
                 1.0,  1.0,  0.0,
                -1.0,  1.0,  0.0,
                 1.0, -1.0,  0.0,
                 1.0, -1.0,  0.0,
                -1.0,  1.0,  0.0,                 
                -1.0, -1.0,  0.0
            ];
        }

        function getUnitCubeVertices() {
            return [
                -0.5, 0.5, 0.5,
                0.5, 0.5, 0.5,
                0.5, -0.5, 0.5,
                -0.5, -0.5, 0.5,
                -0.5, 0.5, -0.5,
                0.5, 0.5, -0.5,
                0.5, -0.5, -0.5,
                -0.5, -0.5, -0.5
            ]
        }

        function getCubeIndices() {
            return [
                3, 1, 0, 3, 2, 1, // front
                2, 5, 1, 2, 6, 5, // right
                7, 5, 6, 7, 4, 5, // back
                7, 0, 4, 7, 3, 0, // left
                0, 5, 4, 0, 1, 5, // top
                7, 2, 3, 7, 6, 2  // bottom
            ]
        }

        // Hex must be a 7-character hex code (e.g. #FF00FF) and alpha should be in the range [0, 1]
        // Adapted from https://stackoverflow.com/questions/21646738/convert-hex-to-rgba
        function hexToRGBA(hex, alpha) {
            var r = parseInt(hex.slice(1, 3), 16);
            var g = parseInt(hex.slice(3, 5), 16);
            var b = parseInt(hex.slice(5, 7), 16);

            var a = alpha;
            if (a) {
                a = clamp(a, 0, 1);
            } else {
                a = 0;
            }

            return [r / 255, g / 255, b / 255, a];
        }

        function getVertexColorInputs() {
            var result = [];
            for (var i = 0; i < 8; ++i) {
                result.push(document.getElementById("vertex" + i + "color"));
            }
            return result;
        }

        function getCubeColors() {
            var result = [];
            var colorInputs = getVertexColorInputs();
            for (var i = 0; i < colorInputs.length; ++i) {
                result = result.concat(hexToRGBA(colorInputs[i].value, 1));
            }
            return result;
        }

        function getSquareColors() {
            var colors = [];
            for (var i = 0; i < 6; ++i) {
                colors = colors.concat([0.5, 0.5, 1.0, 1.0]);
            }
            return colors;
        }

        // From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random
        function getRandomIntInclusive(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(Math.random() * (max - min + 1)) + min; 
        }

        function generateCubeLocations(regionSize, regionsPerAxis) {
            var locations = [];
            var halfAxis = Math.trunc(regionsPerAxis / 2);
            for (var x = -halfAxis; x <= halfAxis; ++x) {
                for (var y = -halfAxis; y <= halfAxis; ++y) {
                    for (var z = -halfAxis; z <= halfAxis; ++z) {
                        var position = [x * regionSize + getRandomIntInclusive(0, regionSize),
                                        y * regionSize + getRandomIntInclusive(0, regionSize),
                                        z * regionSize + getRandomIntInclusive(0, regionSize)];
                        locations.push(position);
                    }
                }
            }
            return locations;
        }

        function drawScene(env) {
            var gl = env.gl;

            var frameTime = env.currTime - env.prevTime;
            var speed = 500;
            if (env.keysDown["W".charCodeAt(0)]) {
                env.camera.moveAlongLook(frameTime / speed);
            } 
            if (env.keysDown["S".charCodeAt(0)]) {
                env.camera.moveAlongLook(-frameTime / speed);
            }
            if (env.keysDown["A".charCodeAt(0)]) {
                env.camera.movePerpendicularToLook(-frameTime / speed);
            }
            if (env.keysDown["D".charCodeAt(0)]) {
                env.camera.movePerpendicularToLook(frameTime / speed);
            }
            if (env.keysDown["Q".charCodeAt(0)]) {
                env.camera.addPosition([0, frameTime / speed, 0]);
            }
            if (env.keysDown["E".charCodeAt(0)]) {
                env.camera.addPosition([0, -frameTime / speed, 0]);
            }

            env.camera.addYaw(-env.deltaX / 100);
            env.camera.addPitch(-env.deltaY / 100);
            env.deltaX = 0;
            env.deltaY = 0;

            gl.viewport(0, 0, env.canvas.width, env.canvas.height);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT);

            var identityMatrix = mat4.identity(mat4.create());
            var projectionMatrix = mat4.create();
            var canvasRatio = env.canvas.width / env.canvas.height;
            mat4.perspective(projectionMatrix, 45, canvasRatio, 0.1, 100.0);

            var timeDelta = env.currTime - env.startTime;

            gl.bindBuffer(gl.ARRAY_BUFFER, env.cubeVertexBufferWrapper.buffer);
            gl.vertexAttribPointer(env.shaderProgramWrapper.aVertexPosition, 
                                   env.cubeVertexBufferWrapper.itemSize,
                                   gl.FLOAT,
                                   false,
                                   0,
                                   0);
            gl.bindBuffer(gl.ARRAY_BUFFER, env.cubeColorBufferWrapper.buffer);
            gl.vertexAttribPointer(env.shaderProgramWrapper.aVertexColor,
                                   env.cubeColorBufferWrapper.itemSize,
                                   gl.FLOAT,
                                   false,
                                   0,
                                   0);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, env.cubeIndexBufferWrapper.buffer);
            gl.uniformMatrix4fv(env.shaderProgramWrapper.uProjectionMatrix, false, projectionMatrix);
            
            for (var index = 0; index < env.cubeLocations.length; ++index) {
                cubeLocation = vec3.fromValues(env.cubeLocations[index][0],
                                               env.cubeLocations[index][1],
                                               env.cubeLocations[index][2]);
                var scaleInput = document.getElementById("cube-scale");
                var scaleValue = clamp(scaleInput.value, 0.5, 5);

                var cubeTransformMatrix = mat4.identity(mat4.create());
                mat4.translate(cubeTransformMatrix, 
                               cubeTransformMatrix, 
                               cubeLocation);
                mat4.scale(cubeTransformMatrix,
                           cubeTransformMatrix,
                           vec3.fromValues(scaleValue, scaleValue, scaleValue));
                var modelViewMatrix = mat4.multiply(mat4.create(),
                                                    env.camera.getWorldToCameraMatrix(),
                                                    cubeTransformMatrix);

                gl.uniformMatrix4fv(env.shaderProgramWrapper.uModelViewMatrix, 
                                    false, 
                                    modelViewMatrix);
                gl.drawElements(gl.TRIANGLES, env.cubeIndexBufferWrapper.numItems, gl.UNSIGNED_SHORT, 0);
            }
        }

        function tick(time, env) {
            if (env.count == 0) {
                env.startTime = time;
                env.prevTime = time;
                env.currTime = time;
            } else {
                env.prevTime = env.currTime;
                env.currTime = time;                
            }

            // Draw
            drawScene(env)

            env.count++;

            if (!env.keysDown["X".charCodeAt(0)]) {
                requestAnimFrame(function (time) { tick(time, env); });
            } else {
                document.exitPointerLock();
            }

        }

        function handleKeyDown(env, event) {
            env.keysDown[event.keyCode] = true;
        }

        function handleKeyUp(env, event) {
            env.keysDown[event.keyCode] = false;
        }

        function handleClick(env, event) {
            if (!env.pointerLocked) {
                console.log("requesting pointer lock");
                env.canvas.requestPointerLock();
            } else {
                console.log("click while locked");
            }
        }

        function handlePointerLockChange(env) {
            if (document.pointerLockElement === env.canvas) {
                console.log("pointer locked on canvas");
                env.pointerLocked = true;
            } else if (document.pointerLockElement) {
                console.log("pointer locked on unexpected element:");
                console.log(document.pointerLockElement);
                env.pointerLocked = false;
            } else {
                console.log("pointer not locked");
                env.pointerLocked = false;
            }
        }

        function handlePointerLockError(env) {
            console.log("pointer lock error");
            alert("Pointer lock failed");
        }

        function handleMouseMove(env, event) {
            if (env.pointerLocked) {
                env.deltaX += event.movementX;
                env.deltaY += event.movementY;
            }
        }

        function handleColorChange(env, event) {
            updateCubeColors(env);
        }

        function getSettingsCategories() {
            var storage = window.localStorage;
            if (!storage.getItem("__categories__")) {
                storage.setItem("__categories__", JSON.stringify([]));
            }
            return JSON.parse(storage.getItem("__categories__"));
        }

        function setSettingsCategories(categories) {
            var storage = window.localStorage;
            storage.setItem("__categories__", JSON.stringify(categories));
        }

        function ensureSettingsCategory(category) {
            var categories = getSettingsCategories();
            if (-1 == categories.findIndex(function(elt) { return elt == category; })) {
                categories.unshift(category);
                setSettingsCategories(categories);
                // Can't get storage events on the same page that triggered them.
                // According to https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API
                populateCategorySelect();
            }
        }

        function setSettingsItem(category, key, value) {
            ensureSettingsCategory(category);
            var storage = window.localStorage;
            storage.setItem(category + "/" + key, value);
        }

        function getSettingsItem(category, key) {
            var storage = window.localStorage;
            return storage.getItem(category + "/" + key);
        }

        function handleStoreSettings(event) {
            var storage = window.localStorage;

            var category = document.getElementById("settings-name").value;

            setSettingsItem(category, "cube-scale", document.getElementById("cube-scale").value);

            var vertexColorInputs = getVertexColorInputs();
            for (var i = 0; i < vertexColorInputs.length; ++i) {
                setSettingsItem(category, vertexColorInputs[i].id, vertexColorInputs[i].value);
            }
        }

        function populateCategorySelect() {
            var categorySelect = document.getElementById("category-select");
            var categories = getSettingsCategories();

            var children = categorySelect.children;
            while (children.length != 0) {
                children[0].remove();
            }

            for (var i = 0; i < categories.length; ++i) {
                var option = document.createElement("option");
                option.text = categories[i];
                categorySelect.appendChild(option);
            }
        }

        // handle storage changed -> update category list
        // insert new categories at the front of the list
        // add menu and button to read settings
        // add function to load settings from storage
        // add button to delete a settings category

        function start() {
            var canvas = document.getElementById("glCanvas");

            // Initialize OpenGL
            var gl = initWebGL(canvas);
            if (!gl) {
                alert("Unable to initialize WebGL. Your browser may not support it.");
                return;
            }

            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clearDepth(1.0);
            gl.enable(gl.DEPTH_TEST);
            gl.depthFunc(gl.LEQUAL);
            gl.enable(gl.CULL_FACE);
            gl.cullFace(gl.BACK);
            gl.clear(gl.COLOR_BUFFER_BIT || GL_DEPTH_BUFFER_BIT);

            // Initialize Shaders
            var vertexShaderElement = document.getElementById("shader-vs");
            var vertexShaderText = vertexShaderElement.firstChild.textContent;

            var fragmentShaderElement = document.getElementById("shader-fs");
            var fragmentShaderText = fragmentShaderElement.firstChild.textContent;

            var shaderProgramWrapper = createShaderProgram(gl, vertexShaderText, fragmentShaderText);
            if (!shaderProgramWrapper) {
                alert("Did not get shaderProgramWrapper");
                return;
            }

            // Set uniform locations on the wrapper
            gl.useProgram(shaderProgramWrapper.program);

            shaderProgramWrapper.aVertexPosition = 
                gl.getAttribLocation(shaderProgramWrapper.program, "aVertexPosition");
            gl.enableVertexAttribArray(shaderProgramWrapper.aVertexPosition);

            shaderProgramWrapper.aVertexColor = 
                gl.getAttribLocation(shaderProgramWrapper.program, "aVertexColor");
            gl.enableVertexAttribArray(shaderProgramWrapper.aVertexColor);

            shaderProgramWrapper.uProjectionMatrix = 
                gl.getUniformLocation(shaderProgramWrapper.program, "uProjectionMatrix");
            
            shaderProgramWrapper.uModelViewMatrix = 
                gl.getUniformLocation(shaderProgramWrapper.program, "uModelViewMatrix");

            // Initialize Buffers
            var triangleVertexBufferWrapper = createFloatBuffer(gl, 
                                                                getTriangleVertices(),
                                                                3, 
                                                                gl.STATIC_DRAW);
            var squareVertexBufferWrapper = createFloatBuffer(gl, 
                                                              getSquareVertices(), 
                                                              3,
                                                              gl.STATIC_DRAW);
            var triangleColorBufferWrapper = createFloatBuffer(gl,
                                                               getTriangleColors(),
                                                               4,
                                                               gl.STATIC_DRAW);
            var squareColorBufferWrapper = createFloatBuffer(gl,
                                                             getSquareColors(),
                                                             4,
                                                             gl.STATIC_DRAW);
            var cubeVertexBufferWrapper = createFloatBuffer(gl,
                                                            getUnitCubeVertices(),
                                                            3,
                                                            gl.STATIC_DRAW);
            var cubeIndexBufferWrapper = createU16ElementBuffer(gl,
                                                                getCubeIndices(),
                                                                gl.STATIC_DRAW);
            var cubeColorBufferWrapper = createFloatBuffer(gl,
                                                           getCubeColors(),
                                                           4,
                                                           gl.STATIC_DRAW);

            var env = {};
            env.count = 0;
            env.gl = gl;
            env.canvas = canvas;
            env.triangleVertexBufferWrapper = triangleVertexBufferWrapper;
            env.squareVertexBufferWrapper = squareVertexBufferWrapper;
            env.triangleColorBufferWrapper = triangleColorBufferWrapper;
            env.squareColorBufferWrapper = squareColorBufferWrapper;
            env.cubeVertexBufferWrapper = cubeVertexBufferWrapper;
            env.cubeIndexBufferWrapper = cubeIndexBufferWrapper;
            env.cubeColorBufferWrapper = cubeColorBufferWrapper;
            env.shaderProgramWrapper = shaderProgramWrapper;
            env.keysDown = {};
            env.camera = new Camera();
            env.pointerLocked = false;
            env.deltaX = 0;
            env.deltaY = 0;
            env.cubeLocations = generateCubeLocations(10, 10);

            // Generate HTML
            populateCategorySelect();

            // Set up handlers
            document.onkeydown = function(event) { handleKeyDown(env, event); };
            document.onkeyup = function(event) { handleKeyUp(env, event); };
            document.onpointerlockchange = function() { handlePointerLockChange(env); };
            document.onpointerlockerror = function() { handlePointerLockError(env); };
            document.onmousemove = function(event) { handleMouseMove(env, event); };

            canvas.onclick = function(event) { handleClick(env, event); };

            var vertexColorInputs = getVertexColorInputs();
            for (var i = 0; i < vertexColorInputs.length; ++i) {
                vertexColorInputs[i].onchange = function(event) { handleColorChange(env, event); };
            }

            var storeSettingsButton = document.getElementById("store-settings");
            storeSettingsButton.onclick = function(event) { handleStoreSettings(event); }

            requestAnimFrame(function(time) { tick(time, env); });
        }
    </script>

    <style>
        .wrapper {
            display: grid;
            grid-template-columns: auto auto auto;
        }
        * {box-sizing: border-box;}

        .wrapper {
          border: 2px solid #f76707;
          border-radius: 5px;
          background-color: #fff4e6;
        }

        .wrapper > div {
          border: 2px solid #ffa94d;
          border-radius: 5px;
          background-color: #ffd8a8;
          padding: 1em;
          color: #d9480f;
        }

        #settings-header {
            font-weight: bold;
            font-size: 20px;
        }

    </style>
</head>

<body onload="start()">
    <div class="wrapper">
        <div>
            <canvas id="glCanvas" style="border: none;" width="800" height="600"></canvas>
        </div>
        <div>
            Cube Scale: <input id="cube-scale" type="number" max=5 min=0.5 step=0.1 value=1>
            <br />
            <br />
            <div id="settings-header">Cube Colors</div>
            Vertex 1: <input id="vertex0color" type="color" value="#00FFFF">
            <br />
            Vertex 2: <input id="vertex1color" type="color" value="#FFFFFF">
            <br />
            Vertex 3: <input id="vertex2color" type="color" value="#FF00FF">
            <br />
            Vertex 4: <input id="vertex3color" type="color" value="#0000FF">
            <br />
            Vertex 5: <input id="vertex4color" type="color" value="#00FF00">
            <br />
            Vertex 6: <input id="vertex5color" type="color" value="#FFFF00">
            <br />
            Vertex 7: <input id="vertex6color" type="color" value="#FF0000">
            <br />
            Vertex 8: <input id="vertex7color" type="color" value="#000000">
            <br />
            Settings Name: <input id="settings-name" type="text">
            <br />
            <input id="store-settings" type="button" value="Store Settings">
        </div>
        <div>
            <div id="settings-header">Select Settings</div>
            <br />
            <select id="category-select"></select>
            <br />
            <input id="load-settings" type="button" value="Load Settings">
        </div>
</body>

</html>
